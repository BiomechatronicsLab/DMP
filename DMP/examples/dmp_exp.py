print(__doc__)

import numpy as np
import matplotlib.pyplot as plt
import sys
sys.path.append('/home/yzheng/PycharmProjects/DMP/DMP')
from dmp_behavior import DMPBehavior



def make_minimum_jerk(start, goal, execution_time=1.0, dt=0.01):
    """Create a minimum jerk trajectory.
    A minimum jerk trajectory from :math:`x_0` to :math:`g` minimizes
    the third time derivative of the positions:
    .. math::
        \\arg \min_{x_0, \ldots, x_T} \int_{t=0}^T \dddot{x}(t)^2 dt
    The trajectory will have
    .. code-block:: python
        n_steps = 1 + execution_time / dt
    steps because we start at 0 seconds and end at execution_time seconds.
    Parameters
    ----------
    start : array-like, shape (n_task_dims,)
        Initial state
    goal : array-like, shape (n_task_dims,)
        Goal
    execution_time : float, optional (default: 1)
        Execution time in seconds
    dt : float, optional (default: 0.01)
        Time between successive steps in seconds
    Returns
    -------
    X : array, shape (n_task_dims, n_steps, 1)
        The positions of the trajectory
    Xd : array, shape (n_task_dims, n_steps, 1)
        The velocities of the trajectory
    Xdd : array, shape (n_task_dims, n_steps, 1)
        The accelerations of the trajectory
    """
    x0 = np.asarray(start)
    g = np.asarray(goal)
    if x0.shape != g.shape:
        raise ValueError("Shape of initial state %s and goal %s must be equal"
                         % (x0.shape, g.shape))

    n_task_dims = x0.shape[0]
    n_steps = 1 + int(execution_time / dt)

    X = np.zeros((n_task_dims, n_steps, 1))
    Xd = np.zeros((n_task_dims, n_steps, 1))
    Xdd = np.zeros((n_task_dims, n_steps, 1))

    x = x0.copy()
    xd = np.zeros(n_task_dims)
    xdd = np.zeros(n_task_dims)

    X[:, 0, 0] = x
    tau = execution_time
    for t in range(1, n_steps):
        tau = execution_time - t * dt

        if tau >= dt:
            dist = g - x

            a1 = 0
            a0 = xdd * tau ** 2
            v1 = 0
            v0 = xd * tau

            t1 = dt
            t2 = dt ** 2
            t3 = dt ** 3
            t4 = dt ** 4
            t5 = dt ** 5

            c1 = (6. * dist + (a1 - a0) / 2. - 3. * (v0 + v1)) / tau ** 5
            c2 = (-15. * dist + (3. * a0 - 2. * a1) / 2. + 8. * v0 +
                  7. * v1) / tau ** 4
            c3 = (10. * dist + (a1 - 3. * a0) / 2. - 6. * v0 -
                  4. * v1) / tau ** 3
            c4 = xdd / 2.
            c5 = xd
            c6 = x

            x = c1 * t5 + c2 * t4 + c3 * t3 + c4 * t2 + c5 * t1 + c6
            xd = (5. * c1 * t4 + 4 * c2 * t3 + 3 * c3 * t2 + 2 * c4 * t1 + c5)
            xdd = (20. * c1 * t3 + 12. * c2 * t2 + 6. * c3 * t1 + 2. * c4)

        X[:, t, 0] = x
        Xd[:, t, 0] = xd
        Xdd[:, t, 0] = xdd

    return X, Xd, Xdd


def dmp_to_trajectory(dmp, y0, g, gd, execution_time):
    """Computes trajectory generated by open-loop controlled DMP."""
    dmp.set_meta_parameters(["y0", "g", "gd", "execution_time"],
                            [y0, g, gd, execution_time])
    return dmp.gen_traj()


x0 = np.zeros(2)
g = np.ones(2)
dt = 0.001
execution_time = 1.0
dmp = DMPBehavior(execution_time, dt, n_features=20)
dmp.init(6, 6)
dmp.set_meta_parameters(["y0", "g"], [x0, g])
X_demo = make_minimum_jerk(x0, g, execution_time, dt)[0]
dmp.LearnfromDemo(X_demo)

plt.figure()
plt.subplots_adjust(wspace=0.3, hspace=0.6)

for gx in np.linspace(0.5, 1.5, 6):
    g_new = np.array([gx, 1.0])
    X, Xd, Xdd = dmp_to_trajectory(dmp, x0, g_new, np.zeros(2), 1.0)

    ax = plt.subplot(321)
    ax.set_title("Goal adaption")
    ax.set_xlabel("$x_1$")
    ax.set_ylabel("$x_2$")
    ax.plot(X[:, 0], X[:, 1])

    ax = plt.subplot(322)
    ax.set_title("Velocity profile")
    ax.set_xlabel("$t$")
    ax.set_ylabel("$v$")
    ax.plot(np.linspace(0, 1, X.shape[0]),
            np.sqrt(Xd[:, 0] ** 2 + Xd[:, 1] ** 2))

for gxd in np.linspace(-1.5, 1.5, 6):
    gd = np.array([gxd, 0.0])
    X, Xd, Xdd = dmp_to_trajectory(dmp, x0, g, gd, 1.0)

    ax = plt.subplot(323)
    ax.set_title("Goal velocity adaption")
    ax.set_xlabel("$x_1$")
    ax.set_ylabel("$x_2$")
    ax.plot(X[:, 0], X[:, 1])

    ax = plt.subplot(324)
    ax.set_title("Velocity profile")
    ax.set_xlabel("$t$")
    ax.set_ylabel("$v$")
    ax.plot(np.linspace(0, 1, X.shape[0]),
            np.sqrt(Xd[:, 0] ** 2 + Xd[:, 1] ** 2))

gd = np.array([0.5, 0.0])
for t in np.linspace(0.5, 2.5, 6):
    X, Xd, Xdd = dmp_to_trajectory(dmp, x0, g, gd, t)

    ax = plt.subplot(325)
    ax.set_title("Execution time adaption")
    ax.set_xlabel("$x_1$")
    ax.set_ylabel("$x_2$")
    ax.plot(X[:, 0], X[:, 1])

    ax = plt.subplot(326)
    ax.set_title("Velocity profile")
    ax.set_xlabel("$t$")
    ax.set_ylabel("$v$")
    ax.plot(np.linspace(0, t, X.shape[0]),
            np.sqrt(Xd[:, 0] ** 2 + Xd[:, 1] ** 2))

plt.show()



